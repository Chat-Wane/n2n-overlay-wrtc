<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">N2N-Overlay-Wrtc API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/chat-wane/n2n-overlay-wrtc.git/" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/n2n-overlay.js~Neighbor.html">Neighbor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EventEmitter">EventEmitter</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="n2n-overlay-wrtc">n2n-overlay-wrtc</h1>
<p>This project aims to ease the creation of overlay networks on top of
WebRTC. Additional WebRTC-specific constraints make such projects more difficult
than they should be. For instance, establishing a connection requires a
round-trip of &quot;offers&quot;. Such messages usually transit a dedicated signaling
server. The peers of this project still require a signaling server for their
entrance in the network. Afterwards, peers become signaling servers too, i.e.,
they mediate connections between their direct neighbors.</p>
<p>This module divides the entering arcs (inview) from the outgoing arcs (outview).</p>
<p>The way connections are handled are left to the discretion of overlay protocols
built on top of this module. A peer with two neighbors can ask to one of them to
connect to the other. Several overlay network protocols use neighbor-to-neighbor
interactions to converge to a topology exposing the desired properties.</p>
<h2 id="installation">Installation</h2>
<p>Using npm: <code>$ npm install n2n-overlay-wrtc</code></p>
<p>Using bower: <code>$ bower install n2n-overlay-wrtc</code></p>
<h2 id="documentation">Documentation</h2>
<p>The documentation is avalaible <a href="https://ran3d.github.io/n2n-overlay-wrtc/">here</a></p>
<h2 id="-live-example-https-ran3d-github-io-n2n-overlay-wrtc-example-browser-html-"><a href="https://ran3d.github.io/n2n-overlay-wrtc/example/browser.html">Live Example</a></h2>
<h2 id="usage">Usage</h2>
<pre><code class="lang-js"><code class="source-code prettyprint">var NO = require(&apos;n2n-overlay-wrtc&apos;);

// #1 create a peer. See module neighborhood-wrtc for options
var n1 = new NO(someOptions);

// #2 establish a first connection through any signaling server
n1.connection(callbacksToSignaling);

// #3 connect the neighbor accessible through socket1 to the neighbor
// accessible through socket2. If everything goes right, the former neighbor
// has the latter neighbor in its outview. It is the responsibility of n1 to
// not create self-loop
// #A connect two neighbors
n1.connect(idFrom, idTo);

// #B connect a neighbor to us, idTo is implicitely us
n1.connect(idFrom);

// #C add an arc to a neigbhor, idFrom is implicitely us
n1.connect(null, idTo);

// #4 remove an arc or completely leave the network
// #A it removes an arc. If multiple occurrences of the arcs are found, the
// socket is not destroyed.
n1.disconnect(id);

// #B remove everything
n1.disconnect();

// #5 get the element of the inview, or the outview, or an entry in particular
var inview = n1.get(&apos;inview&apos;);
var outview = n1.get(&apos;outview&apos;);
var entry = n1.get(id);

// #6 send a message to a neighbor using the identifier of the arcs
// targeting a neighbor.
var success = n1.send(id, message);

// #7 retrieve the content of views as a string
var s = n1.toString();</code>
</code></pre>
<pre><code class="lang-js"><code class="source-code prettyprint">// #1 notification that a connection is ready. View is either
// &apos;inview&apos; or &apos;outview&apos;. Id is the identifier of the socket that is ready.
n1.on(&apos;ready&apos;, function(id, view){
  // Maybe a special procedure when you establish
  // the very first connection.
});

// #2 a message has been receive from the identified arc
n1.on(&apos;receive&apos;, function(id, message){
  // do something with the message
});

// #3 event emitted when an arc disconnect. It provides the identifier
// of the disconnected arcs along with the view it comes from.
n1.on(&apos;disconnect&apos;, function(id, view){
  // update view
});

// #4 an arc failed to establish. The view where the fail happened is provided.
n1.on(&apos;fail&apos;, function(view){
  // do something accordingly
});</code>
</code></pre>
<p>Example with a bridge (provided in example folder):</p>
<pre><code class="lang-js"><code class="source-code prettyprint">var NO = require(&apos;n2n-overlay-wrtc&apos;);

var opts = {
  webrtc: {
    trickle:true
  },
  verbose:true
};

// # create 3 peers
var n1 = new NO(opts);
var n2 = new NO(opts);
var n3 = new NO(opts);

var twoconnections = 2 * 2;

var callbacks = function(src, dest){
    return {
        onInitiate: function(offer){
            dest.connection(callbacks(dest, src), offer);
        },
        onAccept: function(offer){
            dest.connection(offer);
        },
        onReady: function(){
            --twoconnections;
            console.log(&quot;Connection established&quot;);
            if (twoconnections &lt;=0){bridge();};
        }
    };
};

// #1 establishing a connection from n1 to n2
var id1 = n1.connection(callbacks(n1, n2));
// #2 establishing a connection from n1 to n3
var id2 = n1.connection(callbacks(n1, n3));
// &gt; console: should see 4 &quot;connection established&quot; messages

// #3 n1 chooses to connect n2 to n3 (neighbor2neighbor connection)
function bridge(){
     entry1 = n1.outview.living.ms.arr[0]; // ugly
     entry2 = n1.outview.living.ms.arr[1]; // probably better way
     console.log(entry1.id+ &apos; -&gt; &apos; +entry2.id);
     n1.connect(entry1.id, entry2.id);

//     // #4 add a direct connection from n2 to n1 (direct connection)
     n2.connect(null, n1.outview.ID);
     n2.connect(null, n1.outview.ID); // x2 but no additionnal connection
//     // #5 add an arc from n1 to n2 at the initiative of n2
     n2.connect(n1.outview.ID);
};</code>
</code></pre>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
